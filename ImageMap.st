MultiByteFileStream subclass: #HtmlFileStream	instanceVariableNames: 'prevPreamble'	classVariableNames: 'TabThing'	poolDictionaries: ''	category: 'ImageMap'!!HtmlFileStream commentStamp: 'mk 8/30/2005 15:10' prior: 0!The Class apes StandardFileStream, but converts the text to HTML before putting it out (primarily intended for printOut).  It can be invoked with	((FileStream fileNamed: 'changes.html') asHtml) fileOutChangesUse usual FileStream methods to put out text converted to	HTML fairly approximating that text  (for best looks, use 	method:, methodHeader:, methodBody:, for code);verbatim: puts text out without conversion;command: put out HTML items, such as <br>, supplying the brackets.header: and trailer: put out an HTML wrapper (preamble and closing text)nextPut does the actual conversion, nextPutAll: defers characters to nextPut.The code is fairly dumb at present, doing a wooden straightforward conversion of the text without attempting to capture the style or fonts in which the original text was rendered.  Tabs are handled awkwardly, using &nbsp, so that probably only leading strings are working right.  Style sheets now permit us to do a much neater looking job if there is interest in improving the looks of things.Example:	Perform		HtmlFileStream example1	and then navigate your browser to file 'example1.html'!!HtmlFileStream methodsFor: 'fileIn/Out' stamp: 'stephaneducasse 2/4/2006 20:31'!copyMethodChunkFrom: aStream	"Overridden to bolden the first line (presumably a method header)"	| terminator code firstLine |	terminator := $!!.	aStream skipSeparators.	code := aStream upTo: terminator.	firstLine := code copyUpTo: Character cr.	firstLine size = code size		ifTrue: [self nextPutAll: code]		ifFalse: [self command: 'b'; nextPutAll: firstLine; command: '/b'.				self nextPutAll: (code copyFrom: firstLine size + 1 to: code size)].	self nextPut: terminator.	[aStream peekFor: terminator] whileTrue:   "case of imbedded (doubled) terminators"			[self nextPut: terminator;				nextPutAll: (aStream upTo: terminator);				nextPut: terminator]! !!HtmlFileStream methodsFor: 'fileIn/Out' stamp: 'stephaneducasse 2/4/2006 20:31'!nextChunk	"Answer the contents of the receiver, up to the next terminator character (!!).  Imbedded terminators are doubled.  Undo and strip out all Html stuff in the stream and convert the characters back.  4/12/96 tk"	| out char did rest |	self skipSeparators.	"Absorb <...><...> also"	out := WriteStream on: (String new: 500).	[self atEnd] whileFalse: [		self peek = $< ifTrue: [self unCommand].	"Absorb <...><...>"		(char := self next) = $&			ifTrue: [				rest := self upTo: $;.				did := out position.				rest = 'lt' ifTrue: [out nextPut: $<].				rest = 'gt' ifTrue: [out nextPut: $>].				rest = 'amp' ifTrue: [out nextPut: $&].				did = out position ifTrue: [					self error: 'new HTML char encoding'.					"Please add it to this code"]]			ifFalse: [char = $!!	"terminator"				ifTrue: [					self peek = $!! ifFalse: [^ out contents].					out nextPut: self next]	"pass on one $!!"				ifFalse: [char asciiValue = 9							ifTrue: [self next; next; next; next "TabThing"].						out nextPut: char]]		].	^ out contents! !!HtmlFileStream methodsFor: 'fileIn/Out' stamp: 'stephaneducasse 2/4/2006 20:31'!skipSeparators	"Bsides the normal spacers, also skip any <...>, html commands.	4/12/96 tk"	| did |	[did := self position.		super skipSeparators.		self unCommand.	"Absorb <...><...>"		did = self position] whileFalse.	"until no change"! !!HtmlFileStream methodsFor: 'HTML'!command: aString	"Append HTML commands directly without translation.  Caller should not include < or >.  Note that font change info comes through here!!  4/5/96 tk"	(aString includes: $<) ifTrue: [self error: 'Do not put < or > in arg'].		"We do the wrapping with <> here!!  Don't put it in aString."	^ self verbatim: '<', aString, '>'! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'stephaneducasse 2/4/2006 20:31'!header	"append the HTML header.  Be sure to call trailer after you put out the data.	4/4/96 tk"	| cr |	cr := String with: Character cr.	self command: 'HTML'; verbatim: cr.	self command: 'HEAD'; verbatim: cr.	self command: 'TITLE'.	self nextPutAll: '"', self name, '"'.	self command: '/TITLE'; verbatim: cr.	self command: '/HEAD'; verbatim: cr.	self command: 'BODY'; verbatim: cr.! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/01/1999 13:59'!nextPut: char	"Put a character on the file, but translate it first. 4/6/96 tk 1/1/98 acg"	char = $< ifTrue: [^ super nextPutAll: '&lt;'].	char = $> ifTrue: [^ super nextPutAll: '&gt;'].	char = $& ifTrue: [^ super nextPutAll: '&amp;'].	char asciiValue = 13 "return" 		ifTrue: [self command: 'br'].	char = $	"tab" 		ifTrue: [self verbatim: TabThing. ^super nextPut: char].	^ super nextPut: char! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'nice 3/19/2010 19:13'!nextPutAll: aString	"Write the whole string, translating as we go. 4/6/96 tk"	"Slow, but faster than using aString asHtml?"	^aString do: [:each | self nextPut: each].! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'stephaneducasse 2/4/2006 20:31'!trailer	"append the HTML trailer.  Call this just before file close.	4/4/96 tk"	| cr |	cr := String with: Character cr.	self command: '/BODY'; verbatim: cr.	self command: '/HTML'; verbatim: cr.! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/02/1999 00:38'!verbatim: aString	"Put out the string without HTML conversion. 1/1/99 acg"	super nextPutAll: aString	"'super verbatim:' in the 2.3beta draft didn't perform as expected -- the code was printed with conversion.  In a sense, that wouldn't make sense either -- we don't want strictly verbatim printing, just printing without the HTML conversion (that is, skipping around just the nextPut: and nextPutAll: for just this Class).  If there were intermediate conversions (say, CRLF!!), we would want those to happen as advertised -- perhaps we should use a differently named selector, perhaps something like nextPutWithoutHTMLConversion:, so that verbatim isn't overridden?"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlFileStream class	instanceVariableNames: ''!!HtmlFileStream class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:32'!initialize   "HtmlFileStream initialize"	TabThing := '&nbsp;&nbsp;&nbsp;'"I took Ted's suggestion to use &nbsp, which works far better for the HTML.  Style sheets provide an alternative, possibly better, solution since they permit finer-grain control of the HTML formatting, and thus would permit capturing the style in which text was originally rendered.  Internal tabbings would still get lost. 1/1/99 acg."! !!HtmlFileStream class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:32'!example1	"This example shows how HtmlFileStream class can be used for generating HTML file."	| htmlFileStream |	htmlFileStream := HtmlFileStream newFrom: (FileStream fileNamed: 'example1.html').	htmlFileStream		header;		command: 'H1';		nextPutAll: 'Hello, world!!';		command: '/H1';		trailer;		close.! !!HtmlFileStream class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:32'!newFrom: aFileStream	"Answer an HtmlFileStream that is 'like' aFileStream.  As a side-effect, the surviving fileStream answered by this method replaces aFileStream on the finalization registry. 1/6/99 acg"	|inst|	inst := super newFrom: aFileStream.	StandardFileStream unregister: aFileStream.	HtmlFileStream register: inst.	inst detectLineEndConvention.	^inst! !Object subclass: #ImageMap	instanceVariableNames: 'pageSize printStringLimit itemsLimit objects references html'	classVariableNames: ''	poolDictionaries: ''	category: 'ImageMap'!!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/20/2007 11:57'!build	objects withIndexDo: [:obj :index | 			(index \\ pageSize) = 1 			ifTrue: [ self startFileFor: (index // pageSize + 1) ].		html verbatim: '<div class="object">'.					html verbatim: '<a name="', (index \\ pageSize) asString, '">'.						html verbatim: '<div class="printString">'.			self print: obj.			html verbatim: '</div>'.			obj class = CompiledMethod 				ifTrue: [					html verbatim: '<div class="decompileString">'.					 html nextPutAll: '*** DECOMPILE STRING ERROR ***'.					html verbatim: '</div>'.				].						html verbatim: '<div class="properties">'.			self printLink: obj class.			html nextPutAll: ' | '.			self print: obj class instSize.			html nextPutAll: ' | '.			self print: obj basicSize.			html nextPutAll: ' | '.			html nextPutAll: index asString.			html verbatim: '</div>'.					html verbatim: '<table class="slots">'.				1 to: obj class instSize do: [:i |				html verbatim: '<tr class="variable">'.				html verbatim: '<th>'.				[html nextPutAll: (obj class allInstVarNames at: i)] ifError: [:e | html nextPutAll: 'ERROR: ', e asString.].				html verbatim: '</th>'.				html verbatim: '<td>'.				self printLink: (obj instVarAt: i).				html verbatim: '</td>'.				html verbatim: '</tr>'.				].						(obj class isVariable and: [(obj class == CompiledMethod) not]) ifTrue: [				1 to: (obj basicSize min: itemsLimit) do: [:i |					html verbatim: '<tr class="item">'.					html verbatim: '<th>'.					html nextPutAll: (i asString).					html verbatim: '</th>'.					html verbatim: '<td>'.					self printLink: (obj basicAt: i).					html verbatim: '</td>'.					html verbatim: '</tr>'.]].			html verbatim: '</table>'.			html verbatim: '<div class="references">'.				(references at: index) do: [:ref |										| page idx |					page := ref // pageSize + 1.					idx := ref \\ pageSize.					html verbatim: '<a href="', page asString, '.html#', idx asString, '">'.					html nextPutAll: ref asString..					html verbatim: '</a>'. ].					html verbatim: '</div>'.			html verbatim: '</div>'		].	self printNavigation.	html verbatim: '</body></html>'.	html close.! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/20/2007 12:08'!countReferences	| ref log |	log := (FileStream forceNewFileNamed: 'log.txt').	log := Stdio stdout.	log nextPutAll: objects size asString; lf; flush.	objects withIndexDo: [:obj :index |		log nextPutAll: index asString; lf.		1 to: obj class instSize do: [:i |			ref := obj instVarAt: i.			((ref class == SmallInteger) 				| (ref == nil) 				| (ref == true) 				| (ref == false)) 				ifFalse: [					| ri |					ri := self indexOf: ref.					(ri == 0) ifFalse: [(references at: ri) add: index ]]].		(obj class isVariable and: [(obj class == CompiledMethod) not]) ifTrue: [			1 to: obj basicSize do: [:i |				ref := obj basicAt: i.				((ref class == SmallInteger) 					| (ref == nil) 					| (ref == true) 					| (ref == false)) 					ifFalse: [						| ri |						ri := self indexOf: ref.						(ri == 0) ifFalse:[(references at: ri) add: index ]]]]].	log close.		! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/20/2007 11:34'!indexOf: anObject	| address stop found |			address := 1.	found := false.	stop := objects size.	[ address <= stop and: [ found not ] ] whileTrue: [		(objects at: address) == anObject			ifTrue: [ found := true. address := address - 1 ].		address := address + 1 ].		^ found 		ifTrue: [ address ]		ifFalse: [ 0 ].! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pavel.krivanek 10/19/2010 19:47'!initialize	| object count |	pageSize := 200.	printStringLimit := 5000.	itemsLimit := 256.		Smalltalk garbageCollect.	count := 0.	object := 0 someObject.	[object == 0] whileFalse: [		count := count + 1.		object := object nextObject ].	objects := Array new: count*2.	count := 0.	object := 0 someObject.	[object == 0] whileFalse: [		object == objects			ifFalse: [				count := count + 1.				objects at: count put: object.].		object := object nextObject ].		Smalltalk garbageCollect.		objects := objects first: count.			references := objects collect: [:o | Set new: 10 ].	self countReferences.! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/16/2007 21:46'!print: anObject	[ html nextPutAll: (anObject printStringLimitedTo: printStringLimit) ] 		ifError: [ html verbatim: '<span class="error">*** PRINT ERROR ***</span>'].! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/20/2007 11:35'!printLink: anObject	| address |		anObject class = SmallInteger ifTrue: [		html nextPutAll: anObject asString.		^  self ].			address := self indexOf: anObject.		(address = 0) ifFalse: [		| page index |		page := address // pageSize + 1.		index := address \\ pageSize.		html verbatim: '<a href="', page asString, '.html#', index asString, '">'.		 ].								[	html nextPutAll: (anObject printStringLimitedTo: printStringLimit).		html verbatim: (' &nbsp;&nbsp; <span class="reference">[#', address asString, ']</span>').] 			ifError: [ html verbatim: '<span class="error">*** PRINT ERROR ***</span>'].			(address = 0) ifFalse: [ html verbatim: '</a>'. ].			! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/17/2007 09:52'!printNavigation	html verbatim: '<div class="navigation">'.		1 to: (objects size // pageSize + 1 )  do: [:i|		html verbatim: '<a href="', i asString, '.html">', i asString, '</a> ' ].		html verbatim: '</div>'.	! !!ImageMap methodsFor: 'as yet unclassified' stamp: 'pk 6/17/2007 09:52'!startFileFor: pageNumber	html ifNotNil: [ 		self printNavigation.		html verbatim: '</body></html>'.		html close ].	html := HtmlFileStream newFrom: (		(MultiByteFileStream forceNewFileNamed: (pageNumber asString, '.html'))			converter: UTF8TextConverter new;			yourself).		html verbatim: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">	<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">	<head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="style.css" /></head><body>'.! !HtmlFileStream initialize!ImageMap new build!SmalltalkImage current snapshot: false andQuit: true.